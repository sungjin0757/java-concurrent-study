## Item 80. 스레드보다는 실행자, 태스크, 스트림을 애용하라
***

`java.util.concurrent` 패키지가 등장했습니다. 이 패키지는 실행자 프레임워크라고 하는 
인터페이스 기반의 유연한 태스크 실행 기능을 담고 있습니다.

```java
ExecutorService exec = Executors.newSingleThreadExecutir();
```

위의 코드 하나로 뛰어난 작업큐를 생성할 수 있습니다.

다음은 이 실행자에 실행할 태스크를 넘기는 방법입니다.
```java
exec.execute(runnable);
```

그리고 종료하는 방법입니다.

```java
exec.shutdown();
```

실행자 서비스의 기능은 이 외에도 많습니다.
- 특정 태스크가 완료되기를 기다린다.
- 태스크 모음 중 아무것 하나 혹은 모든 태스크가 완료되기를 기다린다.
- 실행자 서비스가 종료하기를 기다린다.
- 완료된 태스크들의 결과를 차례로 받는다.
- 태스크를 특정 시간에 혹은 주기적으로 실행하게 된다.

큐를 둘 이상의 스레드가 처리하게 하고 싶다면 간단히 다른 정적 팩터리를 이용하여
다른 종류의 실행자 서비스를 생성하면 됩니다.

스레드 풀의 개수는 사용자가 알아서 적용할 수 있으며, 필요한 실행자 대부분은 `java.util.concurrent.Executors`
를 통해 만들수 있고 평범하지 않은 실행자를 원한다면 `ThreadPoolExecutor` 클래스를 직접 사용해도 됩니다.

실행자 서비스를 사용하기에 까다로운 애플리케이션도 있습니다.
작은 프로그램이나 가벼운 서버라면 `Executors.newCachedThreadPool`이 일반적으로 좋은 선택입니다.

하지만, `CachedThreadPool`은 무거운 프로덕션 서버에서는 좋지 않습니다.
왜냐하면, `CachedThreadPool` 에서는 요청받은 태스크들이 큐에 쌓이지 않고 즉시 스레드에 위임돼 실행됩니다.

즉, 가용할 스레드가 없다면 새로 하나를 생성합니다. 서버가 아주 무겁다면 CPU 이용률이 한계치를 초과하고,
새로운 태스크가 도착하는 족족 또 다른 스레드를 생성하며 상황을 더욱 악화시킵니다.

따라서, 스레드 개수를 고정한 `Executors.newFixedThreadPool` 을 선택하거나
`ThreadPoolExecutor` 를 직접 사용하는 것이 좋습니다.

<br></br>

작업 큐를 손수 만드는 일은 삼가야 하고, 스레드를 직접 다루는 것도 일반적으로 삼가야 합니다.
스레드를 직접 다루면 `Thread`가 작업 단위와 수행 메커니즘 역할을 모두 수행하게 됩니다.
반면, 실행자 프레임워크에서는 작업 단위와 실행 메커니즘이 분리 됩니다.
작업 단위를 나타내는 핵심 추상 개념이 태스크입니다. 

태스크에는 크게 두가지 `Runnable` 과 `Callable` 이 있으며, 태스크를 수행하는 일반적인 메커니즘이 바로 실행자 서비스 입니다.
태스크 수행을 실행자 서비스에 맡기면 원하는 태스크 수행 정책을 선택할 수 있고, 핵심은 실행자 프레임워크가 작업 수행을 담당해줍니다.

<br></br>

또한 실행자 프레임워크는 포크-조인 태스크를 지원하도록 확장 되엌ㅆ습니다.
포크-조인 태스크는 포크-조인 풀이라는 특별한 실행자 서비스가 실행해줍니다.

포크-조인 태스크의 인스턴스는 작은 하위 태스크로 나뉠 수 있고, 포크조인풀을 구성하는
스레드들이 이 태스크들을 처리하며, 일을 먼저 끝낸 스레드는 다른 스레드의 남은 태스크를 가져와 대신 처리할수도 있습니다.

이렇게 하여 모든 스레드가 바쁘게 움직여 CPU를 최대한 활용하면서 높은 처리량과 낮은 지연시간을 달성합니다.

물론 포크-조인 태스크를 직접 작성하고 튜닝하기란 어렵지만, 포크-조인 풀을 이용해 만든 병렬 스트림을 이용하면 적은 노력으로 그 이점을 얻을 수 있다고 합니다.